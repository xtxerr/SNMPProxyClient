// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: snmpproxy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Snmpproxy_V1_AuthProtocol: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case md5 // = 1
  case sha // = 2
  case sha224 // = 3
  case sha256 // = 4
  case sha384 // = 5
  case sha512 // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .md5
    case 2: self = .sha
    case 3: self = .sha224
    case 4: self = .sha256
    case 5: self = .sha384
    case 6: self = .sha512
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .md5: return 1
    case .sha: return 2
    case .sha224: return 3
    case .sha256: return 4
    case .sha384: return 5
    case .sha512: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Snmpproxy_V1_AuthProtocol] = [
    .unspecified,
    .md5,
    .sha,
    .sha224,
    .sha256,
    .sha384,
    .sha512,
  ]

}

enum Snmpproxy_V1_PrivProtocol: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case des // = 1
  case aes // = 2
  case aes192 // = 3
  case aes256 // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .des
    case 2: self = .aes
    case 3: self = .aes192
    case 4: self = .aes256
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .des: return 1
    case .aes: return 2
    case .aes192: return 3
    case .aes256: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Snmpproxy_V1_PrivProtocol] = [
    .unspecified,
    .des,
    .aes,
    .aes192,
    .aes256,
  ]

}

enum Snmpproxy_V1_SecurityLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case noAuthNoPriv // = 1
  case authNoPriv // = 2
  case authPriv // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .noAuthNoPriv
    case 2: self = .authNoPriv
    case 3: self = .authPriv
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .noAuthNoPriv: return 1
    case .authNoPriv: return 2
    case .authPriv: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Snmpproxy_V1_SecurityLevel] = [
    .unspecified,
    .noAuthNoPriv,
    .authNoPriv,
    .authPriv,
  ]

}

struct Snmpproxy_V1_Envelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request/Response correlation. Push messages use id=0.
  var id: UInt64 = 0

  var payload: Snmpproxy_V1_Envelope.OneOf_Payload? = nil

  /// Client → Server
  var auth: Snmpproxy_V1_AuthRequest {
    get {
      if case .auth(let v)? = payload {return v}
      return Snmpproxy_V1_AuthRequest()
    }
    set {payload = .auth(newValue)}
  }

  var monitor: Snmpproxy_V1_MonitorRequest {
    get {
      if case .monitor(let v)? = payload {return v}
      return Snmpproxy_V1_MonitorRequest()
    }
    set {payload = .monitor(newValue)}
  }

  var unmonitor: Snmpproxy_V1_UnmonitorRequest {
    get {
      if case .unmonitor(let v)? = payload {return v}
      return Snmpproxy_V1_UnmonitorRequest()
    }
    set {payload = .unmonitor(newValue)}
  }

  var listTargets: Snmpproxy_V1_ListTargetsRequest {
    get {
      if case .listTargets(let v)? = payload {return v}
      return Snmpproxy_V1_ListTargetsRequest()
    }
    set {payload = .listTargets(newValue)}
  }

  var getTarget: Snmpproxy_V1_GetTargetRequest {
    get {
      if case .getTarget(let v)? = payload {return v}
      return Snmpproxy_V1_GetTargetRequest()
    }
    set {payload = .getTarget(newValue)}
  }

  var getHistory: Snmpproxy_V1_GetHistoryRequest {
    get {
      if case .getHistory(let v)? = payload {return v}
      return Snmpproxy_V1_GetHistoryRequest()
    }
    set {payload = .getHistory(newValue)}
  }

  var subscribe: Snmpproxy_V1_SubscribeRequest {
    get {
      if case .subscribe(let v)? = payload {return v}
      return Snmpproxy_V1_SubscribeRequest()
    }
    set {payload = .subscribe(newValue)}
  }

  var unsubscribe: Snmpproxy_V1_UnsubscribeRequest {
    get {
      if case .unsubscribe(let v)? = payload {return v}
      return Snmpproxy_V1_UnsubscribeRequest()
    }
    set {payload = .unsubscribe(newValue)}
  }

  /// Status & Config (Client → Server)
  var getServerStatus: Snmpproxy_V1_GetServerStatusRequest {
    get {
      if case .getServerStatus(let v)? = payload {return v}
      return Snmpproxy_V1_GetServerStatusRequest()
    }
    set {payload = .getServerStatus(newValue)}
  }

  var getSessionInfo: Snmpproxy_V1_GetSessionInfoRequest {
    get {
      if case .getSessionInfo(let v)? = payload {return v}
      return Snmpproxy_V1_GetSessionInfoRequest()
    }
    set {payload = .getSessionInfo(newValue)}
  }

  var updateTarget: Snmpproxy_V1_UpdateTargetRequest {
    get {
      if case .updateTarget(let v)? = payload {return v}
      return Snmpproxy_V1_UpdateTargetRequest()
    }
    set {payload = .updateTarget(newValue)}
  }

  var getConfig: Snmpproxy_V1_GetConfigRequest {
    get {
      if case .getConfig(let v)? = payload {return v}
      return Snmpproxy_V1_GetConfigRequest()
    }
    set {payload = .getConfig(newValue)}
  }

  var setConfig: Snmpproxy_V1_SetConfigRequest {
    get {
      if case .setConfig(let v)? = payload {return v}
      return Snmpproxy_V1_SetConfigRequest()
    }
    set {payload = .setConfig(newValue)}
  }

  /// Server → Client
  var authResp: Snmpproxy_V1_AuthResponse {
    get {
      if case .authResp(let v)? = payload {return v}
      return Snmpproxy_V1_AuthResponse()
    }
    set {payload = .authResp(newValue)}
  }

  var monitorResp: Snmpproxy_V1_MonitorResponse {
    get {
      if case .monitorResp(let v)? = payload {return v}
      return Snmpproxy_V1_MonitorResponse()
    }
    set {payload = .monitorResp(newValue)}
  }

  var unmonitorResp: Snmpproxy_V1_UnmonitorResponse {
    get {
      if case .unmonitorResp(let v)? = payload {return v}
      return Snmpproxy_V1_UnmonitorResponse()
    }
    set {payload = .unmonitorResp(newValue)}
  }

  var listTargetsResp: Snmpproxy_V1_ListTargetsResponse {
    get {
      if case .listTargetsResp(let v)? = payload {return v}
      return Snmpproxy_V1_ListTargetsResponse()
    }
    set {payload = .listTargetsResp(newValue)}
  }

  var getTargetResp: Snmpproxy_V1_GetTargetResponse {
    get {
      if case .getTargetResp(let v)? = payload {return v}
      return Snmpproxy_V1_GetTargetResponse()
    }
    set {payload = .getTargetResp(newValue)}
  }

  var getHistoryResp: Snmpproxy_V1_GetHistoryResponse {
    get {
      if case .getHistoryResp(let v)? = payload {return v}
      return Snmpproxy_V1_GetHistoryResponse()
    }
    set {payload = .getHistoryResp(newValue)}
  }

  var subscribeResp: Snmpproxy_V1_SubscribeResponse {
    get {
      if case .subscribeResp(let v)? = payload {return v}
      return Snmpproxy_V1_SubscribeResponse()
    }
    set {payload = .subscribeResp(newValue)}
  }

  var unsubscribeResp: Snmpproxy_V1_UnsubscribeResponse {
    get {
      if case .unsubscribeResp(let v)? = payload {return v}
      return Snmpproxy_V1_UnsubscribeResponse()
    }
    set {payload = .unsubscribeResp(newValue)}
  }

  /// Status & Config (Server → Client)
  var getServerStatusResp: Snmpproxy_V1_GetServerStatusResponse {
    get {
      if case .getServerStatusResp(let v)? = payload {return v}
      return Snmpproxy_V1_GetServerStatusResponse()
    }
    set {payload = .getServerStatusResp(newValue)}
  }

  var getSessionInfoResp: Snmpproxy_V1_GetSessionInfoResponse {
    get {
      if case .getSessionInfoResp(let v)? = payload {return v}
      return Snmpproxy_V1_GetSessionInfoResponse()
    }
    set {payload = .getSessionInfoResp(newValue)}
  }

  var updateTargetResp: Snmpproxy_V1_UpdateTargetResponse {
    get {
      if case .updateTargetResp(let v)? = payload {return v}
      return Snmpproxy_V1_UpdateTargetResponse()
    }
    set {payload = .updateTargetResp(newValue)}
  }

  var getConfigResp: Snmpproxy_V1_GetConfigResponse {
    get {
      if case .getConfigResp(let v)? = payload {return v}
      return Snmpproxy_V1_GetConfigResponse()
    }
    set {payload = .getConfigResp(newValue)}
  }

  var setConfigResp: Snmpproxy_V1_SetConfigResponse {
    get {
      if case .setConfigResp(let v)? = payload {return v}
      return Snmpproxy_V1_SetConfigResponse()
    }
    set {payload = .setConfigResp(newValue)}
  }

  /// Server → Client (Push, id=0)
  var sample: Snmpproxy_V1_Sample {
    get {
      if case .sample(let v)? = payload {return v}
      return Snmpproxy_V1_Sample()
    }
    set {payload = .sample(newValue)}
  }

  /// Server → Client (Error response)
  var error: Snmpproxy_V1_Error {
    get {
      if case .error(let v)? = payload {return v}
      return Snmpproxy_V1_Error()
    }
    set {payload = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// Client → Server
    case auth(Snmpproxy_V1_AuthRequest)
    case monitor(Snmpproxy_V1_MonitorRequest)
    case unmonitor(Snmpproxy_V1_UnmonitorRequest)
    case listTargets(Snmpproxy_V1_ListTargetsRequest)
    case getTarget(Snmpproxy_V1_GetTargetRequest)
    case getHistory(Snmpproxy_V1_GetHistoryRequest)
    case subscribe(Snmpproxy_V1_SubscribeRequest)
    case unsubscribe(Snmpproxy_V1_UnsubscribeRequest)
    /// Status & Config (Client → Server)
    case getServerStatus(Snmpproxy_V1_GetServerStatusRequest)
    case getSessionInfo(Snmpproxy_V1_GetSessionInfoRequest)
    case updateTarget(Snmpproxy_V1_UpdateTargetRequest)
    case getConfig(Snmpproxy_V1_GetConfigRequest)
    case setConfig(Snmpproxy_V1_SetConfigRequest)
    /// Server → Client
    case authResp(Snmpproxy_V1_AuthResponse)
    case monitorResp(Snmpproxy_V1_MonitorResponse)
    case unmonitorResp(Snmpproxy_V1_UnmonitorResponse)
    case listTargetsResp(Snmpproxy_V1_ListTargetsResponse)
    case getTargetResp(Snmpproxy_V1_GetTargetResponse)
    case getHistoryResp(Snmpproxy_V1_GetHistoryResponse)
    case subscribeResp(Snmpproxy_V1_SubscribeResponse)
    case unsubscribeResp(Snmpproxy_V1_UnsubscribeResponse)
    /// Status & Config (Server → Client)
    case getServerStatusResp(Snmpproxy_V1_GetServerStatusResponse)
    case getSessionInfoResp(Snmpproxy_V1_GetSessionInfoResponse)
    case updateTargetResp(Snmpproxy_V1_UpdateTargetResponse)
    case getConfigResp(Snmpproxy_V1_GetConfigResponse)
    case setConfigResp(Snmpproxy_V1_SetConfigResponse)
    /// Server → Client (Push, id=0)
    case sample(Snmpproxy_V1_Sample)
    /// Server → Client (Error response)
    case error(Snmpproxy_V1_Error)

  }

  init() {}
}

struct Snmpproxy_V1_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_Sample: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  var timestampMs: Int64 = 0

  var counter: UInt64 = 0

  var text: String = String()

  var valid: Bool = false

  var error: String = String()

  var pollMs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SNMPv2c: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var community: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SNMPv3: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var securityName: String = String()

  var securityLevel: Snmpproxy_V1_SecurityLevel = .unspecified

  /// Auth (required if security_level >= AUTH_NO_PRIV)
  var authProtocol: Snmpproxy_V1_AuthProtocol = .unspecified

  var authPassword: String = String()

  /// Priv (required if security_level == AUTH_PRIV)
  var privProtocol: Snmpproxy_V1_PrivProtocol = .unspecified

  var privPassword: String = String()

  /// Optional context
  var contextName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SNMPConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Snmpproxy_V1_SNMPConfig.OneOf_Version? = nil

  var v2C: Snmpproxy_V1_SNMPv2c {
    get {
      if case .v2C(let v)? = version {return v}
      return Snmpproxy_V1_SNMPv2c()
    }
    set {version = .v2C(newValue)}
  }

  var v3: Snmpproxy_V1_SNMPv3 {
    get {
      if case .v3(let v)? = version {return v}
      return Snmpproxy_V1_SNMPv3()
    }
    set {version = .v3(newValue)}
  }

  var timeoutMs: UInt32 = 0

  var retries: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Version: Equatable, Sendable {
    case v2C(Snmpproxy_V1_SNMPv2c)
    case v3(Snmpproxy_V1_SNMPv3)

  }

  init() {}
}

struct Snmpproxy_V1_Target: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var host: String {
    get {return _storage._host}
    set {_uniqueStorage()._host = newValue}
  }

  var port: UInt32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  var oid: String {
    get {return _storage._oid}
    set {_uniqueStorage()._oid = newValue}
  }

  var intervalMs: UInt32 {
    get {return _storage._intervalMs}
    set {_uniqueStorage()._intervalMs = newValue}
  }

  var bufferSize: UInt32 {
    get {return _storage._bufferSize}
    set {_uniqueStorage()._bufferSize = newValue}
  }

  /// Runtime state
  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var lastPollMs: Int64 {
    get {return _storage._lastPollMs}
    set {_uniqueStorage()._lastPollMs = newValue}
  }

  var lastError: String {
    get {return _storage._lastError}
    set {_uniqueStorage()._lastError = newValue}
  }

  var subscribers: Int32 {
    get {return _storage._subscribers}
    set {_uniqueStorage()._subscribers = newValue}
  }

  var samplesBuffered: Int32 {
    get {return _storage._samplesBuffered}
    set {_uniqueStorage()._samplesBuffered = newValue}
  }

  /// Extended statistics
  var createdAtMs: Int64 {
    get {return _storage._createdAtMs}
    set {_uniqueStorage()._createdAtMs = newValue}
  }

  var pollsTotal: Int64 {
    get {return _storage._pollsTotal}
    set {_uniqueStorage()._pollsTotal = newValue}
  }

  var pollsSuccess: Int64 {
    get {return _storage._pollsSuccess}
    set {_uniqueStorage()._pollsSuccess = newValue}
  }

  var pollsFailed: Int64 {
    get {return _storage._pollsFailed}
    set {_uniqueStorage()._pollsFailed = newValue}
  }

  var avgPollMs: Int32 {
    get {return _storage._avgPollMs}
    set {_uniqueStorage()._avgPollMs = newValue}
  }

  var minPollMs: Int32 {
    get {return _storage._minPollMs}
    set {_uniqueStorage()._minPollMs = newValue}
  }

  var maxPollMs: Int32 {
    get {return _storage._maxPollMs}
    set {_uniqueStorage()._maxPollMs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Snmpproxy_V1_AuthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_AuthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var sessionID: String = String()

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_MonitorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: String = String()

  /// Default: 161
  var port: UInt32 = 0

  var oid: String = String()

  /// Default: 1000
  var intervalMs: UInt32 = 0

  /// Default: 3600
  var bufferSize: UInt32 = 0

  var snmp: Snmpproxy_V1_SNMPConfig {
    get {return _snmp ?? Snmpproxy_V1_SNMPConfig()}
    set {_snmp = newValue}
  }
  /// Returns true if `snmp` has been explicitly set.
  var hasSnmp: Bool {return self._snmp != nil}
  /// Clears the value of `snmp`. Subsequent reads from it will return its default value.
  mutating func clearSnmp() {self._snmp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snmp: Snmpproxy_V1_SNMPConfig? = nil
}

struct Snmpproxy_V1_MonitorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  /// true if new, false if joined existing
  var created: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UnmonitorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UnmonitorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_ListTargetsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional filter
  var filterHost: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_ListTargetsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targets: [Snmpproxy_V1_Target] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetTargetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetTargetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Snmpproxy_V1_Target {
    get {return _target ?? Snmpproxy_V1_Target()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: Snmpproxy_V1_Target? = nil
}

struct Snmpproxy_V1_GetHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetIds: [String] = []

  /// Number of samples (default: 100)
  var lastN: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var history: [Snmpproxy_V1_TargetHistory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_TargetHistory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  var samples: [Snmpproxy_V1_Sample] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SubscribeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SubscribeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var subscribed: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UnsubscribeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Empty = unsubscribe all
  var targetIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UnsubscribeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetServerStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetServerStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// General
  var version: String = String()

  var uptimeMs: Int64 = 0

  var startedAtMs: Int64 = 0

  /// Sessions
  var sessionsActive: Int32 = 0

  var sessionsLost: Int32 = 0

  /// Targets
  var targetsTotal: Int32 = 0

  var targetsPolling: Int32 = 0

  var targetsUnreachable: Int32 = 0

  /// Poller
  var pollerWorkers: Int32 = 0

  var pollerQueueUsed: Int32 = 0

  var pollerQueueCapacity: Int32 = 0

  var pollerHeapSize: Int32 = 0

  /// Statistics (since start)
  var pollsTotal: Int64 = 0

  var pollsSuccess: Int64 = 0

  var pollsFailed: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetSessionInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetSessionInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var tokenID: String = String()

  var createdAtMs: Int64 = 0

  var connectedAtMs: Int64 = 0

  var ownedTargets: [String] = []

  var subscribedTargets: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UpdateTargetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetID: String = String()

  /// 0 = don't change
  var intervalMs: UInt32 = 0

  /// 0 = don't change
  var timeoutMs: UInt32 = 0

  /// 0 = don't change
  var retries: UInt32 = 0

  /// 0 = don't change
  var bufferSize: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_UpdateTargetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var target: Snmpproxy_V1_Target {
    get {return _target ?? Snmpproxy_V1_Target()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: Snmpproxy_V1_Target? = nil
}

struct Snmpproxy_V1_GetConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_GetConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: Snmpproxy_V1_RuntimeConfig {
    get {return _config ?? Snmpproxy_V1_RuntimeConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Snmpproxy_V1_RuntimeConfig? = nil
}

struct Snmpproxy_V1_SetConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 = don't change
  var defaultTimeoutMs: UInt32 = 0

  /// 0 = don't change
  var defaultRetries: UInt32 = 0

  /// 0 = don't change
  var defaultBufferSize: UInt32 = 0

  /// 0 = don't change
  var minIntervalMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Snmpproxy_V1_SetConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var config: Snmpproxy_V1_RuntimeConfig {
    get {return _config ?? Snmpproxy_V1_RuntimeConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Snmpproxy_V1_RuntimeConfig? = nil
}

struct Snmpproxy_V1_RuntimeConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Changeable at runtime
  var defaultTimeoutMs: UInt32 = 0

  var defaultRetries: UInt32 = 0

  var defaultBufferSize: UInt32 = 0

  var minIntervalMs: UInt32 = 0

  /// Read-only (set at startup)
  var pollerWorkers: Int32 = 0

  var pollerQueueSize: Int32 = 0

  var reconnectWindowSec: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "snmpproxy.v1"

extension Snmpproxy_V1_AuthProtocol: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0AUTH_PROTOCOL_UNSPECIFIED\0\u{1}AUTH_PROTOCOL_MD5\0\u{1}AUTH_PROTOCOL_SHA\0\u{1}AUTH_PROTOCOL_SHA224\0\u{1}AUTH_PROTOCOL_SHA256\0\u{1}AUTH_PROTOCOL_SHA384\0\u{1}AUTH_PROTOCOL_SHA512\0")
}

extension Snmpproxy_V1_PrivProtocol: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PRIV_PROTOCOL_UNSPECIFIED\0\u{1}PRIV_PROTOCOL_DES\0\u{1}PRIV_PROTOCOL_AES\0\u{1}PRIV_PROTOCOL_AES192\0\u{1}PRIV_PROTOCOL_AES256\0")
}

extension Snmpproxy_V1_SecurityLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SECURITY_LEVEL_UNSPECIFIED\0\u{1}SECURITY_LEVEL_NO_AUTH_NO_PRIV\0\u{1}SECURITY_LEVEL_AUTH_NO_PRIV\0\u{1}SECURITY_LEVEL_AUTH_PRIV\0")
}

extension Snmpproxy_V1_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{2}\u{9}auth\0\u{1}monitor\0\u{1}unmonitor\0\u{3}list_targets\0\u{3}get_target\0\u{3}get_history\0\u{1}subscribe\0\u{1}unsubscribe\0\u{3}get_server_status\0\u{3}get_session_info\0\u{3}update_target\0\u{3}get_config\0\u{3}set_config\0\u{4}\u{1c}auth_resp\0\u{3}monitor_resp\0\u{3}unmonitor_resp\0\u{3}list_targets_resp\0\u{3}get_target_resp\0\u{3}get_history_resp\0\u{3}subscribe_resp\0\u{3}unsubscribe_resp\0\u{3}get_server_status_resp\0\u{3}get_session_info_resp\0\u{3}update_target_resp\0\u{3}get_config_resp\0\u{3}set_config_resp\0\u{2}\u{12}sample\0\u{2}\u{13}error\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 10: try {
        var v: Snmpproxy_V1_AuthRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .auth(v)
        }
      }()
      case 11: try {
        var v: Snmpproxy_V1_MonitorRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .monitor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .monitor(v)
        }
      }()
      case 12: try {
        var v: Snmpproxy_V1_UnmonitorRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .unmonitor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .unmonitor(v)
        }
      }()
      case 13: try {
        var v: Snmpproxy_V1_ListTargetsRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listTargets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listTargets(v)
        }
      }()
      case 14: try {
        var v: Snmpproxy_V1_GetTargetRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getTarget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getTarget(v)
        }
      }()
      case 15: try {
        var v: Snmpproxy_V1_GetHistoryRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getHistory(v)
        }
      }()
      case 16: try {
        var v: Snmpproxy_V1_SubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribe(v)
        }
      }()
      case 17: try {
        var v: Snmpproxy_V1_UnsubscribeRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .unsubscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .unsubscribe(v)
        }
      }()
      case 18: try {
        var v: Snmpproxy_V1_GetServerStatusRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getServerStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getServerStatus(v)
        }
      }()
      case 19: try {
        var v: Snmpproxy_V1_GetSessionInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getSessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getSessionInfo(v)
        }
      }()
      case 20: try {
        var v: Snmpproxy_V1_UpdateTargetRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .updateTarget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .updateTarget(v)
        }
      }()
      case 21: try {
        var v: Snmpproxy_V1_GetConfigRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getConfig(v)
        }
      }()
      case 22: try {
        var v: Snmpproxy_V1_SetConfigRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setConfig(v)
        }
      }()
      case 50: try {
        var v: Snmpproxy_V1_AuthResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .authResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .authResp(v)
        }
      }()
      case 51: try {
        var v: Snmpproxy_V1_MonitorResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .monitorResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .monitorResp(v)
        }
      }()
      case 52: try {
        var v: Snmpproxy_V1_UnmonitorResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .unmonitorResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .unmonitorResp(v)
        }
      }()
      case 53: try {
        var v: Snmpproxy_V1_ListTargetsResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listTargetsResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listTargetsResp(v)
        }
      }()
      case 54: try {
        var v: Snmpproxy_V1_GetTargetResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getTargetResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getTargetResp(v)
        }
      }()
      case 55: try {
        var v: Snmpproxy_V1_GetHistoryResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getHistoryResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getHistoryResp(v)
        }
      }()
      case 56: try {
        var v: Snmpproxy_V1_SubscribeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeResp(v)
        }
      }()
      case 57: try {
        var v: Snmpproxy_V1_UnsubscribeResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .unsubscribeResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .unsubscribeResp(v)
        }
      }()
      case 58: try {
        var v: Snmpproxy_V1_GetServerStatusResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getServerStatusResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getServerStatusResp(v)
        }
      }()
      case 59: try {
        var v: Snmpproxy_V1_GetSessionInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getSessionInfoResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getSessionInfoResp(v)
        }
      }()
      case 60: try {
        var v: Snmpproxy_V1_UpdateTargetResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .updateTargetResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .updateTargetResp(v)
        }
      }()
      case 61: try {
        var v: Snmpproxy_V1_GetConfigResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getConfigResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getConfigResp(v)
        }
      }()
      case 62: try {
        var v: Snmpproxy_V1_SetConfigResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setConfigResp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setConfigResp(v)
        }
      }()
      case 80: try {
        var v: Snmpproxy_V1_Sample?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sample(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sample(v)
        }
      }()
      case 99: try {
        var v: Snmpproxy_V1_Error?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.payload {
    case .auth?: try {
      guard case .auth(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .monitor?: try {
      guard case .monitor(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .unmonitor?: try {
      guard case .unmonitor(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .listTargets?: try {
      guard case .listTargets(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .getTarget?: try {
      guard case .getTarget(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .getHistory?: try {
      guard case .getHistory(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .unsubscribe?: try {
      guard case .unsubscribe(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .getServerStatus?: try {
      guard case .getServerStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .getSessionInfo?: try {
      guard case .getSessionInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .updateTarget?: try {
      guard case .updateTarget(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .getConfig?: try {
      guard case .getConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .setConfig?: try {
      guard case .setConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .authResp?: try {
      guard case .authResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .monitorResp?: try {
      guard case .monitorResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .unmonitorResp?: try {
      guard case .unmonitorResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .listTargetsResp?: try {
      guard case .listTargetsResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .getTargetResp?: try {
      guard case .getTargetResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .getHistoryResp?: try {
      guard case .getHistoryResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .subscribeResp?: try {
      guard case .subscribeResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .unsubscribeResp?: try {
      guard case .unsubscribeResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .getServerStatusResp?: try {
      guard case .getServerStatusResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .getSessionInfoResp?: try {
      guard case .getSessionInfoResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .updateTargetResp?: try {
      guard case .updateTargetResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .getConfigResp?: try {
      guard case .getConfigResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .setConfigResp?: try {
      guard case .setConfigResp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .sample?: try {
      guard case .sample(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_Envelope, rhs: Snmpproxy_V1_Envelope) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_Error, rhs: Snmpproxy_V1_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sample"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0\u{3}timestamp_ms\0\u{1}counter\0\u{1}text\0\u{1}valid\0\u{1}error\0\u{3}poll_ms\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.counter) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.pollMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 2)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt64Field(value: self.counter, fieldNumber: 3)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 5)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 6)
    }
    if self.pollMs != 0 {
      try visitor.visitSingularInt32Field(value: self.pollMs, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_Sample, rhs: Snmpproxy_V1_Sample) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.text != rhs.text {return false}
    if lhs.valid != rhs.valid {return false}
    if lhs.error != rhs.error {return false}
    if lhs.pollMs != rhs.pollMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SNMPv2c: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SNMPv2c"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}community\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.community) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.community.isEmpty {
      try visitor.visitSingularStringField(value: self.community, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SNMPv2c, rhs: Snmpproxy_V1_SNMPv2c) -> Bool {
    if lhs.community != rhs.community {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SNMPv3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SNMPv3"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}security_name\0\u{3}security_level\0\u{3}auth_protocol\0\u{3}auth_password\0\u{3}priv_protocol\0\u{3}priv_password\0\u{3}context_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.securityName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.securityLevel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.authProtocol) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authPassword) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.privProtocol) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.privPassword) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.contextName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.securityName.isEmpty {
      try visitor.visitSingularStringField(value: self.securityName, fieldNumber: 1)
    }
    if self.securityLevel != .unspecified {
      try visitor.visitSingularEnumField(value: self.securityLevel, fieldNumber: 2)
    }
    if self.authProtocol != .unspecified {
      try visitor.visitSingularEnumField(value: self.authProtocol, fieldNumber: 3)
    }
    if !self.authPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.authPassword, fieldNumber: 4)
    }
    if self.privProtocol != .unspecified {
      try visitor.visitSingularEnumField(value: self.privProtocol, fieldNumber: 5)
    }
    if !self.privPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.privPassword, fieldNumber: 6)
    }
    if !self.contextName.isEmpty {
      try visitor.visitSingularStringField(value: self.contextName, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SNMPv3, rhs: Snmpproxy_V1_SNMPv3) -> Bool {
    if lhs.securityName != rhs.securityName {return false}
    if lhs.securityLevel != rhs.securityLevel {return false}
    if lhs.authProtocol != rhs.authProtocol {return false}
    if lhs.authPassword != rhs.authPassword {return false}
    if lhs.privProtocol != rhs.privProtocol {return false}
    if lhs.privPassword != rhs.privPassword {return false}
    if lhs.contextName != rhs.contextName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SNMPConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SNMPConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}v2c\0\u{1}v3\0\u{3}timeout_ms\0\u{1}retries\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Snmpproxy_V1_SNMPv2c?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v2C(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v2C(v)
        }
      }()
      case 2: try {
        var v: Snmpproxy_V1_SNMPv3?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v3(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v3(v)
        }
      }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timeoutMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.retries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.version {
    case .v2C?: try {
      guard case .v2C(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v3?: try {
      guard case .v3(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.timeoutMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeoutMs, fieldNumber: 3)
    }
    if self.retries != 0 {
      try visitor.visitSingularUInt32Field(value: self.retries, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SNMPConfig, rhs: Snmpproxy_V1_SNMPConfig) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.timeoutMs != rhs.timeoutMs {return false}
    if lhs.retries != rhs.retries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Target"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}host\0\u{1}port\0\u{1}oid\0\u{3}interval_ms\0\u{3}buffer_size\0\u{2}\u{4}state\0\u{3}last_poll_ms\0\u{3}last_error\0\u{1}subscribers\0\u{3}samples_buffered\0\u{4}\u{6}created_at_ms\0\u{3}polls_total\0\u{3}polls_success\0\u{3}polls_failed\0\u{3}avg_poll_ms\0\u{3}min_poll_ms\0\u{3}max_poll_ms\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _host: String = String()
    var _port: UInt32 = 0
    var _oid: String = String()
    var _intervalMs: UInt32 = 0
    var _bufferSize: UInt32 = 0
    var _state: String = String()
    var _lastPollMs: Int64 = 0
    var _lastError: String = String()
    var _subscribers: Int32 = 0
    var _samplesBuffered: Int32 = 0
    var _createdAtMs: Int64 = 0
    var _pollsTotal: Int64 = 0
    var _pollsSuccess: Int64 = 0
    var _pollsFailed: Int64 = 0
    var _avgPollMs: Int32 = 0
    var _minPollMs: Int32 = 0
    var _maxPollMs: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _host = source._host
      _port = source._port
      _oid = source._oid
      _intervalMs = source._intervalMs
      _bufferSize = source._bufferSize
      _state = source._state
      _lastPollMs = source._lastPollMs
      _lastError = source._lastError
      _subscribers = source._subscribers
      _samplesBuffered = source._samplesBuffered
      _createdAtMs = source._createdAtMs
      _pollsTotal = source._pollsTotal
      _pollsSuccess = source._pollsSuccess
      _pollsFailed = source._pollsFailed
      _avgPollMs = source._avgPollMs
      _minPollMs = source._minPollMs
      _maxPollMs = source._maxPollMs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._port) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._oid) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._intervalMs) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._bufferSize) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._lastPollMs) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._lastError) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._subscribers) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._samplesBuffered) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAtMs) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._pollsTotal) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._pollsSuccess) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._pollsFailed) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._avgPollMs) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._minPollMs) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._maxPollMs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 2)
      }
      if _storage._port != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._port, fieldNumber: 3)
      }
      if !_storage._oid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oid, fieldNumber: 4)
      }
      if _storage._intervalMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._intervalMs, fieldNumber: 5)
      }
      if _storage._bufferSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bufferSize, fieldNumber: 6)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 10)
      }
      if _storage._lastPollMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastPollMs, fieldNumber: 11)
      }
      if !_storage._lastError.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastError, fieldNumber: 12)
      }
      if _storage._subscribers != 0 {
        try visitor.visitSingularInt32Field(value: _storage._subscribers, fieldNumber: 13)
      }
      if _storage._samplesBuffered != 0 {
        try visitor.visitSingularInt32Field(value: _storage._samplesBuffered, fieldNumber: 14)
      }
      if _storage._createdAtMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAtMs, fieldNumber: 20)
      }
      if _storage._pollsTotal != 0 {
        try visitor.visitSingularInt64Field(value: _storage._pollsTotal, fieldNumber: 21)
      }
      if _storage._pollsSuccess != 0 {
        try visitor.visitSingularInt64Field(value: _storage._pollsSuccess, fieldNumber: 22)
      }
      if _storage._pollsFailed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._pollsFailed, fieldNumber: 23)
      }
      if _storage._avgPollMs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._avgPollMs, fieldNumber: 24)
      }
      if _storage._minPollMs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minPollMs, fieldNumber: 25)
      }
      if _storage._maxPollMs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxPollMs, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_Target, rhs: Snmpproxy_V1_Target) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._oid != rhs_storage._oid {return false}
        if _storage._intervalMs != rhs_storage._intervalMs {return false}
        if _storage._bufferSize != rhs_storage._bufferSize {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._lastPollMs != rhs_storage._lastPollMs {return false}
        if _storage._lastError != rhs_storage._lastError {return false}
        if _storage._subscribers != rhs_storage._subscribers {return false}
        if _storage._samplesBuffered != rhs_storage._samplesBuffered {return false}
        if _storage._createdAtMs != rhs_storage._createdAtMs {return false}
        if _storage._pollsTotal != rhs_storage._pollsTotal {return false}
        if _storage._pollsSuccess != rhs_storage._pollsSuccess {return false}
        if _storage._pollsFailed != rhs_storage._pollsFailed {return false}
        if _storage._avgPollMs != rhs_storage._avgPollMs {return false}
        if _storage._minPollMs != rhs_storage._minPollMs {return false}
        if _storage._maxPollMs != rhs_storage._maxPollMs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_AuthRequest, rhs: Snmpproxy_V1_AuthRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_AuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0\u{3}session_id\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_AuthResponse, rhs: Snmpproxy_V1_AuthResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_MonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}host\0\u{1}port\0\u{1}oid\0\u{3}interval_ms\0\u{3}buffer_size\0\u{1}snmp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.intervalMs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.bufferSize) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._snmp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.oid.isEmpty {
      try visitor.visitSingularStringField(value: self.oid, fieldNumber: 3)
    }
    if self.intervalMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.intervalMs, fieldNumber: 4)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.bufferSize, fieldNumber: 5)
    }
    try { if let v = self._snmp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_MonitorRequest, rhs: Snmpproxy_V1_MonitorRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.oid != rhs.oid {return false}
    if lhs.intervalMs != rhs.intervalMs {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs._snmp != rhs._snmp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_MonitorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MonitorResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0\u{1}created\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_MonitorResponse, rhs: Snmpproxy_V1_MonitorResponse) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.created != rhs.created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UnmonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnmonitorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UnmonitorRequest, rhs: Snmpproxy_V1_UnmonitorRequest) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UnmonitorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnmonitorResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UnmonitorResponse, rhs: Snmpproxy_V1_UnmonitorResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_ListTargetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTargetsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}filter_host\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filterHost) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filterHost.isEmpty {
      try visitor.visitSingularStringField(value: self.filterHost, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_ListTargetsRequest, rhs: Snmpproxy_V1_ListTargetsRequest) -> Bool {
    if lhs.filterHost != rhs.filterHost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_ListTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTargetsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}targets\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_ListTargetsResponse, rhs: Snmpproxy_V1_ListTargetsResponse) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTargetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetTargetRequest, rhs: Snmpproxy_V1_GetTargetRequest) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTargetResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}target\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetTargetResponse, rhs: Snmpproxy_V1_GetTargetResponse) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHistoryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_ids\0\u{3}last_n\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lastN) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 1)
    }
    if self.lastN != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastN, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetHistoryRequest, rhs: Snmpproxy_V1_GetHistoryRequest) -> Bool {
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.lastN != rhs.lastN {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHistoryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}history\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.history) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.history.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.history, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetHistoryResponse, rhs: Snmpproxy_V1_GetHistoryResponse) -> Bool {
    if lhs.history != rhs.history {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_TargetHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetHistory"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0\u{1}samples\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.samples) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if !self.samples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.samples, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_TargetHistory, rhs: Snmpproxy_V1_TargetHistory) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.samples != rhs.samples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_ids\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SubscribeRequest, rhs: Snmpproxy_V1_SubscribeRequest) -> Bool {
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0\u{1}subscribed\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.subscribed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.subscribed.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subscribed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SubscribeResponse, rhs: Snmpproxy_V1_SubscribeResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.subscribed != rhs.subscribed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UnsubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsubscribeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_ids\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UnsubscribeRequest, rhs: Snmpproxy_V1_UnsubscribeRequest) -> Bool {
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UnsubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsubscribeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UnsubscribeResponse, rhs: Snmpproxy_V1_UnsubscribeResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetServerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetServerStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetServerStatusRequest, rhs: Snmpproxy_V1_GetServerStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetServerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetServerStatusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}uptime_ms\0\u{3}started_at_ms\0\u{4}\u{7}sessions_active\0\u{3}sessions_lost\0\u{4}\u{9}targets_total\0\u{3}targets_polling\0\u{3}targets_unreachable\0\u{4}\u{8}poller_workers\0\u{3}poller_queue_used\0\u{3}poller_queue_capacity\0\u{3}poller_heap_size\0\u{4}\u{7}polls_total\0\u{3}polls_success\0\u{3}polls_failed\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uptimeMs) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startedAtMs) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.sessionsActive) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.sessionsLost) }()
      case 20: try { try decoder.decodeSingularInt32Field(value: &self.targetsTotal) }()
      case 21: try { try decoder.decodeSingularInt32Field(value: &self.targetsPolling) }()
      case 22: try { try decoder.decodeSingularInt32Field(value: &self.targetsUnreachable) }()
      case 30: try { try decoder.decodeSingularInt32Field(value: &self.pollerWorkers) }()
      case 31: try { try decoder.decodeSingularInt32Field(value: &self.pollerQueueUsed) }()
      case 32: try { try decoder.decodeSingularInt32Field(value: &self.pollerQueueCapacity) }()
      case 33: try { try decoder.decodeSingularInt32Field(value: &self.pollerHeapSize) }()
      case 40: try { try decoder.decodeSingularInt64Field(value: &self.pollsTotal) }()
      case 41: try { try decoder.decodeSingularInt64Field(value: &self.pollsSuccess) }()
      case 42: try { try decoder.decodeSingularInt64Field(value: &self.pollsFailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.uptimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.uptimeMs, fieldNumber: 2)
    }
    if self.startedAtMs != 0 {
      try visitor.visitSingularInt64Field(value: self.startedAtMs, fieldNumber: 3)
    }
    if self.sessionsActive != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionsActive, fieldNumber: 10)
    }
    if self.sessionsLost != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionsLost, fieldNumber: 11)
    }
    if self.targetsTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.targetsTotal, fieldNumber: 20)
    }
    if self.targetsPolling != 0 {
      try visitor.visitSingularInt32Field(value: self.targetsPolling, fieldNumber: 21)
    }
    if self.targetsUnreachable != 0 {
      try visitor.visitSingularInt32Field(value: self.targetsUnreachable, fieldNumber: 22)
    }
    if self.pollerWorkers != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerWorkers, fieldNumber: 30)
    }
    if self.pollerQueueUsed != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerQueueUsed, fieldNumber: 31)
    }
    if self.pollerQueueCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerQueueCapacity, fieldNumber: 32)
    }
    if self.pollerHeapSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerHeapSize, fieldNumber: 33)
    }
    if self.pollsTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.pollsTotal, fieldNumber: 40)
    }
    if self.pollsSuccess != 0 {
      try visitor.visitSingularInt64Field(value: self.pollsSuccess, fieldNumber: 41)
    }
    if self.pollsFailed != 0 {
      try visitor.visitSingularInt64Field(value: self.pollsFailed, fieldNumber: 42)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetServerStatusResponse, rhs: Snmpproxy_V1_GetServerStatusResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.uptimeMs != rhs.uptimeMs {return false}
    if lhs.startedAtMs != rhs.startedAtMs {return false}
    if lhs.sessionsActive != rhs.sessionsActive {return false}
    if lhs.sessionsLost != rhs.sessionsLost {return false}
    if lhs.targetsTotal != rhs.targetsTotal {return false}
    if lhs.targetsPolling != rhs.targetsPolling {return false}
    if lhs.targetsUnreachable != rhs.targetsUnreachable {return false}
    if lhs.pollerWorkers != rhs.pollerWorkers {return false}
    if lhs.pollerQueueUsed != rhs.pollerQueueUsed {return false}
    if lhs.pollerQueueCapacity != rhs.pollerQueueCapacity {return false}
    if lhs.pollerHeapSize != rhs.pollerHeapSize {return false}
    if lhs.pollsTotal != rhs.pollsTotal {return false}
    if lhs.pollsSuccess != rhs.pollsSuccess {return false}
    if lhs.pollsFailed != rhs.pollsFailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetSessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetSessionInfoRequest, rhs: Snmpproxy_V1_GetSessionInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetSessionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionInfoResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{3}token_id\0\u{3}created_at_ms\0\u{3}connected_at_ms\0\u{4}\u{6}owned_targets\0\u{3}subscribed_targets\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.createdAtMs) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.connectedAtMs) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.ownedTargets) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.subscribedTargets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    if self.createdAtMs != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAtMs, fieldNumber: 3)
    }
    if self.connectedAtMs != 0 {
      try visitor.visitSingularInt64Field(value: self.connectedAtMs, fieldNumber: 4)
    }
    if !self.ownedTargets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ownedTargets, fieldNumber: 10)
    }
    if !self.subscribedTargets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subscribedTargets, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetSessionInfoResponse, rhs: Snmpproxy_V1_GetSessionInfoResponse) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.createdAtMs != rhs.createdAtMs {return false}
    if lhs.connectedAtMs != rhs.connectedAtMs {return false}
    if lhs.ownedTargets != rhs.ownedTargets {return false}
    if lhs.subscribedTargets != rhs.subscribedTargets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UpdateTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTargetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_id\0\u{3}interval_ms\0\u{3}timeout_ms\0\u{1}retries\0\u{3}buffer_size\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.intervalMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timeoutMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.retries) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.bufferSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.intervalMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.intervalMs, fieldNumber: 2)
    }
    if self.timeoutMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeoutMs, fieldNumber: 3)
    }
    if self.retries != 0 {
      try visitor.visitSingularUInt32Field(value: self.retries, fieldNumber: 4)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.bufferSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UpdateTargetRequest, rhs: Snmpproxy_V1_UpdateTargetRequest) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.intervalMs != rhs.intervalMs {return false}
    if lhs.timeoutMs != rhs.timeoutMs {return false}
    if lhs.retries != rhs.retries {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_UpdateTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateTargetResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0\u{1}target\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_UpdateTargetResponse, rhs: Snmpproxy_V1_UpdateTargetResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs._target != rhs._target {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetConfigRequest, rhs: Snmpproxy_V1_GetConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_GetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}config\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_GetConfigResponse, rhs: Snmpproxy_V1_GetConfigResponse) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}default_timeout_ms\0\u{3}default_retries\0\u{3}default_buffer_size\0\u{3}min_interval_ms\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.defaultTimeoutMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.defaultRetries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.defaultBufferSize) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.minIntervalMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.defaultTimeoutMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultTimeoutMs, fieldNumber: 1)
    }
    if self.defaultRetries != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultRetries, fieldNumber: 2)
    }
    if self.defaultBufferSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultBufferSize, fieldNumber: 3)
    }
    if self.minIntervalMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minIntervalMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SetConfigRequest, rhs: Snmpproxy_V1_SetConfigRequest) -> Bool {
    if lhs.defaultTimeoutMs != rhs.defaultTimeoutMs {return false}
    if lhs.defaultRetries != rhs.defaultRetries {return false}
    if lhs.defaultBufferSize != rhs.defaultBufferSize {return false}
    if lhs.minIntervalMs != rhs.minIntervalMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_SetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0\u{1}config\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_SetConfigResponse, rhs: Snmpproxy_V1_SetConfigResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs._config != rhs._config {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Snmpproxy_V1_RuntimeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}default_timeout_ms\0\u{3}default_retries\0\u{3}default_buffer_size\0\u{3}min_interval_ms\0\u{4}\u{6}poller_workers\0\u{3}poller_queue_size\0\u{3}reconnect_window_sec\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.defaultTimeoutMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.defaultRetries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.defaultBufferSize) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.minIntervalMs) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.pollerWorkers) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.pollerQueueSize) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.reconnectWindowSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.defaultTimeoutMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultTimeoutMs, fieldNumber: 1)
    }
    if self.defaultRetries != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultRetries, fieldNumber: 2)
    }
    if self.defaultBufferSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultBufferSize, fieldNumber: 3)
    }
    if self.minIntervalMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minIntervalMs, fieldNumber: 4)
    }
    if self.pollerWorkers != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerWorkers, fieldNumber: 10)
    }
    if self.pollerQueueSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pollerQueueSize, fieldNumber: 11)
    }
    if self.reconnectWindowSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.reconnectWindowSec, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Snmpproxy_V1_RuntimeConfig, rhs: Snmpproxy_V1_RuntimeConfig) -> Bool {
    if lhs.defaultTimeoutMs != rhs.defaultTimeoutMs {return false}
    if lhs.defaultRetries != rhs.defaultRetries {return false}
    if lhs.defaultBufferSize != rhs.defaultBufferSize {return false}
    if lhs.minIntervalMs != rhs.minIntervalMs {return false}
    if lhs.pollerWorkers != rhs.pollerWorkers {return false}
    if lhs.pollerQueueSize != rhs.pollerQueueSize {return false}
    if lhs.reconnectWindowSec != rhs.reconnectWindowSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
